"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CookiesHelper = exports.getSameSiteContext = exports.addCookieJarCookiesToRequest = exports.areUrlsSameSite = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const url_1 = require("url");
const network_1 = require("../../../../network");
const cookies_1 = require("../../../../server/lib/util/cookies");
/**
 * Whether or not a url's scheme, domain, and top-level domain match to determine whether or not
 * a cookie is considered first-party. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#third-party_cookies
 * for more details.
 * @param {string} url1 - the first url
 * @param {string} url2 - the second url
 * @returns {boolean} whether or not the URL Scheme, Domain, and TLD match. This is called same-site and
 * is allowed to have a different port or subdomain. @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site#directives
 * for more details.
 */
const areUrlsSameSite = (url1, url2) => {
    if (!url1 || !url2)
        return false;
    const { port: port1, ...parsedUrl1 } = network_1.cors.parseUrlIntoDomainTldPort(url1);
    const { port: port2, ...parsedUrl2 } = network_1.cors.parseUrlIntoDomainTldPort(url2);
    // If HTTPS, ports NEED to match. Otherwise, HTTP ports can be different and are same origin
    const doPortsPassSameSchemeCheck = port1 !== port2 ? (port1 !== '443' && port2 !== '443') : true;
    return doPortsPassSameSchemeCheck && lodash_1.default.isEqual(parsedUrl1, parsedUrl2);
};
exports.areUrlsSameSite = areUrlsSameSite;
const addCookieJarCookiesToRequest = (applicableCookieJarCookies = [], requestCookieStringArray = []) => {
    const cookieMap = new Map();
    const requestCookies = requestCookieStringArray.map((cookie) => cookies_1.CookieJar.parse(cookie)).filter((cookie) => cookie !== undefined);
    // Always have cookies in the jar overwrite cookies in the request if they are the same
    requestCookies.forEach((cookie) => cookieMap.set(cookie.key, cookie));
    // Two or more cookies on the same request can happen per https://www.rfc-editor.org/rfc/rfc6265
    // But if a value for that cookie already exists in the cookie jar, do NOT add the cookie jar cookie
    applicableCookieJarCookies.forEach((cookie) => {
        if (cookieMap.get(cookie.key)) {
            cookieMap.delete(cookie.key);
        }
    });
    const requestCookiesThatNeedToBeAdded = Array.from(cookieMap).map(([key, cookie]) => cookie);
    return applicableCookieJarCookies.concat(requestCookiesThatNeedToBeAdded).map((cookie) => cookie.cookieString()).join('; ');
};
exports.addCookieJarCookiesToRequest = addCookieJarCookiesToRequest;
// sameSiteContext is a concept for tough-cookie's cookie jar that helps it
// simulate what a browser would do when determining whether or not it should
// be set from a response or a attached to a response. it shouldn't be confused
// with a cookie's SameSite property, though that also plays a role when
// setting/getting a cookie from the tough-cookie cookie jar. see tough-cookie's
// own explanation of sameSiteContext for more information:
// see https://github.com/salesforce/tough-cookie#samesite-cookies
const getSameSiteContext = (autUrl, requestUrl, isAUTFrameRequest) => {
    // if there's no AUT URL, it's a request for the first URL visited, or if
    // the request origin is considered the same site as the AUT origin;
    // both indicate that it's not a cross-site request
    if (!autUrl || (0, exports.areUrlsSameSite)(autUrl, requestUrl)) {
        return 'strict';
    }
    // being an AUT frame request means it's via top-level navigation, and we've
    // ruled out same-origin navigation, so the context is 'lax'.
    // anything else is a non-navigation, cross-site request
    return isAUTFrameRequest ? 'lax' : 'none';
};
exports.getSameSiteContext = getSameSiteContext;
const comparableCookieString = (toughCookie) => {
    return (0, lodash_1.default)(toughCookie)
        .pick('key', 'value', 'domain', 'path')
        .toPairs()
        .sortBy(([key]) => key)
        .map(([key, value]) => `${key}=${value}`)
        .join('; ');
};
const areCookiesEqual = (cookieA, cookieB) => {
    return comparableCookieString(cookieA) === comparableCookieString(cookieB);
};
const matchesPreviousCookie = (previousCookies, cookie) => {
    return !!previousCookies.find((previousCookie) => {
        return areCookiesEqual(previousCookie, cookie);
    });
};
/**
 * Utility for dealing with cross-origin cookies
 * - Tracks which cookies were added to our server-side cookie jar during
 *   a request, so they can be added to the browser via automation
 * - Provides utility cookie-handling methods that rely on aspects of the
 *   request (url, previous request url, etc)
 */
class CookiesHelper {
    constructor({ cookieJar, currentAUTUrl, request, debug }) {
        this.previousCookies = [];
        this.cookieJar = cookieJar;
        this.currentAUTUrl = currentAUTUrl;
        this.request = request;
        this.debug = debug;
        this.sameSiteContext = (0, exports.getSameSiteContext)(currentAUTUrl, request.url, request.isAUTFrame);
        const parsedRequestUrl = new url_1.URL(request.url);
        this.defaultDomain = parsedRequestUrl.hostname;
    }
    capturePreviousCookies() {
        // this plays a part in adding cross-origin cookies to the browser via
        // automation. if the request doesn't need cross-origin handling, this
        // is a noop
        if (!this.request.needsCrossOriginHandling)
            return;
        this.previousCookies = this.cookieJar.getAllCookies();
    }
    getAddedCookies() {
        // this plays a part in adding cross-origin cookies to the browser via
        // automation. if the request doesn't need cross-origin handling, this
        // is a noop
        if (!this.request.needsCrossOriginHandling)
            return [];
        const afterCookies = this.cookieJar.getAllCookies();
        return afterCookies.reduce((memo, afterCookie) => {
            if (matchesPreviousCookie(this.previousCookies, afterCookie))
                return memo;
            return memo.concat((0, cookies_1.toughCookieToAutomationCookie)(afterCookie, this.defaultDomain));
        }, []);
    }
    setCookie(cookie) {
        const toughCookie = cookies_1.CookieJar.parse(cookie);
        // don't set the cookie in our own cookie jar if the parsed cookie is
        // undefined (meaning it's invalid) or if the browser would not set it
        // because Secure is required for SameSite=None. not all browsers currently
        // currently enforce this, but they're heading in that direction since
        // it's now the standard, so this is more future-proof
        if (!toughCookie || (toughCookie.sameSite === 'none' && !toughCookie.secure)) {
            return;
        }
        try {
            this.cookieJar.setCookie(toughCookie, this.request.url, this.sameSiteContext);
        }
        catch (err) {
            this.debug('adding cookie to jar failed: %s', err.message);
        }
    }
}
exports.CookiesHelper = CookiesHelper;
