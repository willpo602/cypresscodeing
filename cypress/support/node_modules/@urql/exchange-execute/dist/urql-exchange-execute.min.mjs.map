{"version":3,"file":"urql-exchange-execute.min.mjs","sources":["../src/execute.ts"],"sourcesContent":["import {\n  Source,\n  pipe,\n  share,\n  filter,\n  takeUntil,\n  mergeMap,\n  merge,\n  make,\n} from 'wonka';\n\nimport {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  GraphQLTypeResolver,\n  execute,\n} from 'graphql';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  makeResult,\n  makeErrorResult,\n  mergeResultPatch,\n  Operation,\n  OperationResult,\n  getOperationName,\n} from '@urql/core';\n\nexport interface ExecuteExchangeArgs {\n  schema: GraphQLSchema;\n  rootValue?: any;\n  context?: ((op: Operation) => void) | any;\n  fieldResolver?: GraphQLFieldResolver<any, any>;\n  typeResolver?: GraphQLTypeResolver<any, any>;\n}\n\ntype ExecuteParams = Parameters<typeof execute>;\n\nconst asyncIterator =\n  typeof Symbol !== 'undefined' ? Symbol.asyncIterator : null;\n\nconst makeExecuteSource = (\n  operation: Operation,\n  args: ExecuteParams\n): Source<OperationResult> => {\n  return make<OperationResult>(observer => {\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) return;\n        return execute(...args) as any;\n      })\n      .then((result: ExecutionResult | AsyncIterable<ExecutionResult>) => {\n        if (ended || !result) {\n          return;\n        } else if (!asyncIterator || !result[asyncIterator]) {\n          observer.next(makeResult(operation, result as ExecutionResult));\n          return;\n        }\n\n        const iterator: AsyncIterator<ExecutionResult> = result[\n          asyncIterator!\n        ]();\n        let prevResult: OperationResult | null = null;\n\n        function next({\n          done,\n          value,\n        }: {\n          done?: boolean;\n          value: ExecutionResult;\n        }) {\n          if (value) {\n            observer.next(\n              (prevResult = prevResult\n                ? mergeResultPatch(prevResult, value)\n                : makeResult(operation, value))\n            );\n          }\n\n          if (!done && !ended) {\n            return iterator.next().then(next);\n          }\n        }\n\n        return iterator.next().then(next);\n      })\n      .then(() => {\n        observer.complete();\n      })\n      .catch(error => {\n        observer.next(makeErrorResult(operation, error));\n        observer.complete();\n      });\n\n    return () => {\n      ended = true;\n    };\n  });\n};\n\n/** Exchange for executing queries locally on a schema using graphql-js. */\nexport const executeExchange = ({\n  schema,\n  rootValue,\n  context,\n  fieldResolver,\n  typeResolver,\n}: ExecuteExchangeArgs): Exchange => ({ forward }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const executedOps$ = pipe(\n      sharedOps$,\n      filter((operation: Operation) => {\n        return operation.kind === 'query' || operation.kind === 'mutation';\n      }),\n      mergeMap((operation: Operation) => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const calculatedContext =\n          typeof context === 'function' ? context(operation) : context;\n        return pipe(\n          makeExecuteSource(operation, [\n            schema,\n            operation.query,\n            rootValue,\n            calculatedContext,\n            operation.variables,\n            getOperationName(operation.query),\n            fieldResolver,\n            typeResolver,\n          ]),\n          takeUntil(teardown$)\n        );\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      sharedOps$,\n      filter(operation => operation.kind === 'teardown'),\n      forward\n    );\n\n    return merge([executedOps$, forwardedOps$]);\n  };\n};\n"],"names":["sharedOps$","const","makeExecuteSource","iterator","ref","done","next","error","observer","operation","filter"],"mappings":"mdAgHUA,KAANC,6BAQY,sHA9EVC,yJAoBQC,iDAKNC,EAAAC,uBAOaC,sCAQPH,sBAzBKG,kEAiCXC,kBAGAC,EAASF,oGAqBK,gBAEVG,4DA8BNC,oCAFiB"}