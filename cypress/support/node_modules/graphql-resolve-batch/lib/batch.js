'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.createBatchResolver = createBatchResolver;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Creates a GraphQL.js field resolver that batches together multiple resolves
 * together that share the *exact* same GraphQL field selection.
 */
function createBatchResolver(batchResolveFn) {
  // Throw an error early of the batch resolver is not a function instead of
  // throwing an error at query execution time.
  if (typeof batchResolveFn !== 'function') {
    throw new Error('Expected a function as the first argument when creating a batch ' + `resolver. Instead found: '${typeof batchResolveFn}'.`);
  }
  var batcher = new Batcher(batchResolveFn);
  return function (source, args, context, info) {
    return new Promise(function (resolve, reject) {
      batcher.batch(source, args, context, info, resolve, reject);
    });
  };
}

/**
 * A structure that batches GraphQL resolves together based on the GraphQL field
 * nodes.
 */

var Batcher = function () {
  function Batcher(batchResolveFn) {
    _classCallCheck(this, Batcher);

    this._batchResolveFn = batchResolveFn;
    this._batches = new Map();
  }

  /**
   * Registers a batch execution for the provided GraphQL field node ASTs. The
   * batch resolver function should be scheduled to execute on the next tick and
   * the batch resolver finishes the `resolve` and `reject` functions will be
   * executed.
   *
   * We group batches together by the first item in `info.fieldNodes`.
   */


  _createClass(Batcher, [{
    key: 'batch',
    value: function batch(source, args, context, info, resolve, reject) {
      // We only use the first field node because the array is reconstructed for
      // every value. Using only the first node *should not matter*. The nodes
      // should not get reused and we should not be missing any information from
      // the other fields.
      var _info$fieldNodes = _slicedToArray(info.fieldNodes, 1),
          fieldNode = _info$fieldNodes[0];

      var batch = this._batches.get(fieldNode);

      // If no batch currently exists for this array of field nodes then we want
      // to create one.
      if (typeof batch === 'undefined') {
        batch = {
          // We only use the first set of `args`, `context`, and `info` that we
          // are passed.
          //
          // It is mostly safe to assume that these variables will be the same
          // for the same `fieldNodes` from the execution implementation.
          args,
          context,
          info,

          // We will push our sources and promise callbacks into these arrays.
          sources: [],
          callbacks: []
        };
        this._batches.set(fieldNode, batch);
      }

      // Add our source and callbacks to the batch.
      batch.sources.push(source);
      batch.callbacks.push({ resolve, reject });

      // Schedule a resolve if none has already been scheduled.
      this._scheduleResolve();
    }

    /**
     * Schedules a resolve for the next tick if a resolve has not already been
     * scheduled.
     */

  }, {
    key: '_scheduleResolve',
    value: function _scheduleResolve() {
      var _this = this;

      if (!this._hasScheduledResolve) {
        this._hasScheduledResolve = true;
        process.nextTick(function () {
          _this._resolve();
          _this._hasScheduledResolve = false;
        });
      }
    }

    /**
     * Resolves all of the batch callbacks by actually executing the batch
     * resolver.
     */

  }, {
    key: '_resolve',
    value: function _resolve() {
      var _this2 = this;

      // Execute every batch that has accumulated.
      this._batches.forEach(function (batch) {
        // Execute our batch resolver function with the appropriate arguments. We
        // use the `executePromise` function to normalize synchronous and
        // asynchronous execution.
        executePromise(_this2._batchResolveFn, batch.sources, batch.args, batch.context, batch.info).then(
        // If we got back an array of values then we want to resolve all of our
        // callbacks for this batch.
        function (values) {
          // Throw an error if we did not get an array of values back from the
          // batch resolver function.
          if (!Array.isArray(values)) {
            throw new Error('Must return an array of values from the batch resolver ' + 'function. Instead the function returned a ' + `'${Object.prototype.toString.call(values)}'.`);
          }
          // Throw an error if the array of values we got back from the resolver
          // is not equal to the number of values we expected when looking at
          // the sources.
          if (values.length !== batch.sources.length) {
            throw new Error('Must return the same number of values from the batch ' + 'resolver as there were sources. Expected ' + `${batch.sources.length} value(s) but got ` + `${values.length} value(s).`);
          }
          // We want to call all of our callbacks with a value returned by our
          // batch resolver.
          batch.callbacks.forEach(function (_ref, i) {
            var resolve = _ref.resolve,
                reject = _ref.reject;

            // Get the value for this set of callbacks. If it is an error then
            // we want to reject this promise. Otherwise we will resolve to the
            // value.
            var value = values[i];
            if (value instanceof Error) {
              reject(value);
            } else {
              resolve(value);
            }
          });
        })
        // If we got an error we want to reject all of our callbacks.
        .catch(function (error) {
          batch.callbacks.forEach(function (_ref2) {
            var reject = _ref2.reject;

            reject(error);
          });
        });
      });
      // Clean out our batches map.
      this._batches.clear();
    }
  }]);

  return Batcher;
}();

/**
 * Executes a function and *always* returns a function. If the function executes
 * synchronously then the result will be coerced into a promise, and if the
 * function returns a promise then that promise will be returned.
 */


function executePromise(fn) {
  try {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    // Execute the function. We do not bind a `this` variable. This is
    // expected to be done by the caller.
    var result = fn.apply(undefined, args);
    // If the result is thenable (most likely a promise) then we want to return
    // the result directly. Otherwise we will turn the value into a promise with
    // `Promise.resolve`.
    return result && typeof result.then === 'function' ? result : Promise.resolve(result);
  } catch (error) {
    // If the functioned errored synchronously we want to return a promise that
    // immeadiately rejects.
    return Promise.reject(error);
  }
}